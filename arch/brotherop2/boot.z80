; Brother 'OP2' cpmish BIOS Â© 2019 David Given
; This file is distributable under the terms of the 2-clause BSD license.
; See COPYING.cpmish in the distribution root directory for more information.

; This is the executable which is loaded and run by the Brother's OS. It
; gets loaded with BBR=CBR=0x60, CBAR=0x55, which means that DRAM from
; physical addresses 0x65000 to 0x6ffff is mapped to logical 0x5000 to 0xffff.

	maclib brotherop2
	maclib cpmish

start:
	dw MAGIC_OP2

	; In order to safely make system calls we need to show the system ROM
	; at 0x4000-0x7fff. We're currently mapped in at 0x5000, so let's
	; relocate to 0x8000 and adjust the mapping. 
	;
	; IMPORTANT! Remember that
	; even though we're loaded at 0x5000, we've been assembled at 0x8000
	; and addresses will all be wrong.

	; Physically copy our code.

	ld hl, 0x5000
	ld de, 0x8000
	ld bc, end - start
	ldir

	; Switch to running code from the new location.

	jp switch_to_8000
switch_to_8000:

	; ...and raise the B and C boundaries to 0x8000 too.

	ld a, 0x88
	out0a CBAR

	call tty_init
	call tty_putsi
	cpmish_banner 'Brother OP2'
    db 10, 0

	; Load the CCP, BDOS and BIOS for the first time.

load_again:
	ld ix, 0xe400			; low two bytes of physical address
	ld h, 0x06				; high byte of physical address
	ld bc, 0x1000 / 256     ; sector number (zero based)
    inc bc                  ; Brother OS wants one-based sectors
	ld de, (0x10000 - 0xe400) / 256
	ld a, 3                 ; Read sector.
	rst 0x28
    jr c, disk_error

    ; Call CP/M!

    di
    ld a, 0x00              ; B/C blocks start at 0x0000
    out0a CBAR
    jp 0xfa00

disk_error:
    ld a, 6                 ; Finished with disk.
    rst 0x28

    call tty_putsi
    db 'Disk error! Press any key to try again.', 10, 0
    call wait_for_a_key
    jr load_again

wait_for_a_key:
	ld a, 5 ; get a key
	rst 8
	jr nc, wait_for_a_key
	ld a, d
	ret

EMULATE_CLEAR_TO_EOL = 1
EMULATE_CLEAR_TO_EOS = 1
	maclib tty

tty_scroll:
tty_insert_line:
tty_delete_line:
	ret

tty_rawwrite:
	ld hl, (tty_cursorx)
	out0h PORT_VIDEO_Y
	ld h, 0
	add hl, hl
	out0l PORT_VIDEO_X
	cp a, ' '
	jr nz, .1
	xor a
.1
	ld l, 0
	out0l PORT_VIDEO_DATA
	out0a PORT_VIDEO_DATA
	ret

str.banner:

end:

