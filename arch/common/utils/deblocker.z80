; cpmish BIOS Â© 2019 David Given
; This file is distributable under the terms of the 2-clause BSD license.
; See COPYING.cpmish in the distribution root directory for more information.

    maclib cpm
IMPL = not 0
    maclib deblocker
    
label DB_GET
    ld (mode), a        ; save deblock mode
    call calculate_physical
    ret z
    call change_block
    ret z
calculate_buffer_address:
    ld a, (offset)
    rra
    ld h, a
    ld l, 0
    rr l
    ld b, ixh
    ld c, ixl
    add hl, bc
    ld bc, DBS_BUFFER
    add hl, bc

    or 1                ; set nz (success)
    ret

; On entry:
;   BC = CP/M sector
;   DE = CP/M track
; On exit:
;   BC = physical sector
;   DE = physical track
calculate_physical:
    ld a, c             ; save CP/M sector offset
    and 3
    ld (offset), a

    srl b               ; divide sector count by four
    rr c
    srl b
    rr c

    ; Check sector number is in bounds.

    ld a, (ix+DBS_NUM_SECTORS+1)
    cp b
    jr c, error         ; high byte bigger, out of bounds
    jr nz, .1           ; high byte smaller, in bounds
    ld a, c
    cp (ix+DBS_NUM_SECTORS+0)
    jr nc, error        ; low byte equal or bigger, out of bounds
.1

    ; Check track number is in bounds.

    ld a, (ix+DBS_NUM_TRACKS+1)
    cp d
    jr c, error         ; high byte bigger, out of bounds
    jr nz, .2           ; high byte smaller, in bounds
    ld a, e
    cp (ix+DBS_NUM_TRACKS+0)
    jr nc, error        ; low byte equal or bigger, out of bounds
.2

    ; Determine whether the address has changed.

    ld hl, changed
    ld (hl), 0

    ld a, (ix+DBS_CUR_SECTOR+0)
    cp b
    jr nz, .3
    ld a, (ix+DBS_CUR_SECTOR+1)
    cp c
    jr nz, .3
    ld a, (ix+DBS_CUR_TRACK+0)
    cp d
    jr nz, .3
    ld a, (ix+DBS_CUR_TRACK+1)
    cp e
    jr z, success

.3
    ld (hl), 1          ; addressed sector has changed
success:
    or 1                ; set nz (success)
    ret

error:
    xor a               ; set z (error)
    ret
    
change_block:
    ld a, (changed)
    or a
    jr z, success       ; sector number hasn't changed, do nothing

    ld a, (ix+DBS_DIRTY)
    or a                ; was the previous sector dirty?
    jr z, .1

    ld l, (ix+DBS_W512+0) ; yes, write it back
    ld h, (ix+DBS_W512+1)
    push bc
    push de
    call pchl
    pop de
    pop bc
    ret z
    ld (ix+DBS_DIRTY), 0 ; clear dirty flag

.1
    ld (ix+DBS_CUR_SECTOR+1), b
    ld (ix+DBS_CUR_SECTOR+0), c
    ld (ix+DBS_CUR_TRACK+1), d
    ld (ix+DBS_CUR_TRACK+0), e

    ld a, (mode)
    cp 2                ; looking at new block?
    jr z, success       ; if so, don't read
    ld l, (ix+DBS_R512+0)
    ld h, (ix+DBS_R512+1)
pchl:
    jp (hl)

label DB_FLUSH
    ld a, (ix+DBS_DIRTY)
    or a
    jr z, success

    ld l, (ix+DBS_W512+0) ; yes, write it back
    ld h, (ix+DBS_W512+1)
    call pchl
    ret z
    ld (ix+DBS_DIRTY), 0  ; only mark block as clean if write succeeded
    ret

label DB_CAP
    push hl             ; maximum number of blocks

    ld e, (ix+DBS_NUM_SECTORS+0)
    ld d, (ix+DBS_NUM_SECTORS+1)
    ld c, (ix+DBS_NUM_TRACKS+0)
    ld b, (ix+DBS_NUM_TRACKS+1)

    ; Convert DE to CP/M sectors.
    sla e
    rl d
    sla e
    rl d
    ld (iy+DPB_SPT+0), e        ; write to SPT
    ld (iy+DPB_SPT+1), d

    ; BC*DE = DE:HL
    ld hl, 0            ; result
    ld a, 16            ; number of bits
.1
    add hl, hl
    rl e
    rl d                ; de:hl = de:hl*2, overflow to c
    jr nc, .2
    add hl, bc
    jr nc, .2
    inc de
.2
    dec a
    jr nz, .1

    pop bc              ; bc = maximum number of blocks

    ; We have the total number of CP/M sectors in DE:HL. Divide by the block
    ; size to get the number of blocks.
    ld a, (iy+DPB_BSH)
    ; The block shift is n where n is the number of bits to shift a CP/M sector
    ; count to get a block count. So, we want to shift DEHL right by A bits to
    ; get the block count.
.3
    srl d
    rr e
    rr h
    rr l
    dec a
    jr nz, .3

    ; If DE is set, the disk is too big.
    or d                ; A is 0, remember
    or e
    jr z, .4            ; jump if disk fits
    ld h, b
    ld l, c             ; load the maximum number of blocks

.4
    ld a, b
    cp h
    jr c, .5                    ; high byte too big
    jr nz, .6                   ; high byte too low, value in range
    ld a, l
    cp c
    jr c, .6                    ; low byte in range
.5
    ; This disk really is too big.
    ld h, b
    ld l, c
.6
    dec hl              ; actually want count-1
    ld (iy+DPB_DSM+0), l
    ld (iy+DPB_DSM+1), h
    ret

mode:        db 0
offset:      db 0
changed:     db 0
buffer:      dw 0
