; Brother OP2 cpmish BIOS Â© 2020 David Given
; This file is distributable under the terms of the 2-clause BSD license.
; See COPYING.cpmish in the distribution root directory for more information.

    maclib cpm
    maclib cpmish
    maclib brotherop2

    cseg

; BIOS jump table.

label BBASE
    jp BOOTE
    jp WBOOTE
    jp CONSTE
    jp CONINE
    jp CONOUTE
    jp LISTE
    jp PUNCHE
    jp READERE
    jp HOMEE
    jp SELDSKE
    jp SETTRKE
    jp SETSECE
    jp SETDMAE
    jp READE
    jp WRITEE
    jp LISTSTE
    jp SECTRANE

; Actual BIOS entrypoints.
;
; The BIOS calls typically use a simple calling convention where the parameter
; is in BC and the result is returned in A and HL. The docs don't mention
; anything about other registers so we'll assume they can be corrupted. In
; addition, our syscall stuff assumes that on return A = L, just like in the
; BDOS, so we have a single parameter and a single response --- all very simple.

; Cold boot on system startup.
BOOTE:
    ld sp, 0x0100            ; ephemeral user stack

    xor a
    ld (IOBYTE), a           ; reset iobyte and current disk
    ld (CDISK), a

    ld a, 1
    ld (tty_cursory), a

    ; fall through
call_ccp:
    ld a, 0xc3
    ld hl, BBASE + 3         ; init BIOS entrypoint
    ld (0x0000), a
    ld (0x0001), hl

    ld hl, FBASE + 6         ; init BDOS entrypoint
    ld (0x0005), a
    ld (0x0006), hl

    ld a, (CDISK)
    ld c, a                  ; c = current disk
    jp CBASE                 ; pass control to CCP

stop_disk_motor:
    call sysin
    ld a, 6                  ; finished with disk
    rst 0x28
    call sysout
    ret

; Warm boot on application exit.
WBOOTE:
    ld sp, 0x0100            ; ephemeral user stack

    ; Reload the CCP (but not the BDOS or CCP).

    call sysin
	ld ix, 0xe400			; low two bytes of physical address
	ld h, 0x06				; high byte of physical address
	ld bc, (0x1000 / 256) + 1 ; sector number (one based)
	ld de, 8                ; number of sectors
	ld a, 3 ; read sector (maybe)
	rst 0x28
    call sysout
    jr call_ccp

CONSTE:
    ld hl, disk_off_count
    inc (hl)                 ; increment drive motor count and...
    call z, stop_disk_motor  ; ...turn the motor off on rollover

    ld a, 0
    ret

CONINE:
    call stop_disk_motor
    call sysin
.1
    ld a, 5                 ; get a key
    rst 8
    jr nc, .1

    call sysout
    ld a, d

    ret

CONOUTE:
    ld a, c
    jp tty_putc

LISTE:
PUNCHE:
    ret

LISTSTE:
READERE:
return_error:
    ld a, 0xff
    ret

; Selects a drive, returning the address of the DPH in HL (or 0x0000 on
; error).
SELDSKE:
    ld hl, 0
    ld a, c
    or a
    ret nz                  ; return 0 if not drive 0
    ld hl, drive_a_dph
    ret

HOMEE:
    ld bc, 0
    ; fall through
SETTRKE:
    ld a, c
    ld (current_track), bc
    ret

SETSECE:
    ld a, c
    ld (current_sector), bc
    ret

SETDMAE:
    ld (current_dma), bc
    ret

READE:
    xor a                   ; reset disk timer
    ld (disk_off_count), a

    xor a                   ; deblocking mode normal
    call getblock
    ;jr z, return_error

    ld de, (current_dma)
copy_and_return:
    ld bc, 128
    ldir
    xor a
    ret

WRITEE:
    xor a                   ; reset disk timer
    ld (disk_off_count), a

    ld a, c                 ; set deblocking mode
    call getblock
    jr z, return_error

    ld de, (current_dma)
    ex de, hl
    jr copy_and_return

getblock;
    ld ix, drive_a_dbs
    ld bc, (current_sector)
    ld de, (current_track)
    jp db_get

SECTRANE:
    ld h, b
    ld l, c
    ret

EMULATE_CLEAR_TO_EOL = 1
EMULATE_CLEAR_TO_EOS = 1
    maclib tty

tty_rawwrite:
    ld hl, (tty_cursorx)
    out0h PORT_VIDEO_Y
    ld h, 0
    add hl, hl
    out0l PORT_VIDEO_X
    ld l, 0
    out0l PORT_VIDEO_DATA
    out0a PORT_VIDEO_DATA
    ret

tty_scroll:
tty_insert_line:
tty_delete_line:
    ret

DBS_BLOCK_SHIFT = 8 ; 256-byte native sectors
DBS_WANT_DB_CAP = 0 ; don't want the db_cap routine
    maclib deblocker

; Disk handling. On entry, these routines are called with
; ix set to the deblocker structure, and return z on error.

fd_r256:
    push ix
    push af
    push hl
    push bc
    push de
    ld a, 'R'
    call tty_putc
    ld a, (ix+DBS_CUR_TRACK)
    call tty_puthex8
    ld a, '.'
    call tty_putc
    ld a, (ix+DBS_CUR_SECTOR)
    call tty_puthex8
    pop de
    pop bc
    pop hl
    pop af
    pop ix

    push ix
    call fd_setup_read_or_write
    call sysin
    ld a, 3
    rst 0x28
fd_rw_return:
    call sysout
    pop ix
    ;jr nc, disk_error
    or 1
    ret

disk_error:
    xor a                   ; set z (error)
    ret

fd_w256:
    push ix
    call fd_setup_read_or_write
    call sysin
    ld a, 4
    rst 0x28
    jr fd_rw_return

fd_setup_read_or_write:
    ld a, (ix+DBS_CUR_TRACK)
    ld c, a                 ; c = track
    add a, a                ; a = track*2
    add a, c                ; a = track*3 --- this is all that will fit in 8 bits
    ld l, a
    ld h, 0                 ; hl = track*3
    add hl, hl              ; hl = track*6
    add hl, hl              ; hl = track*12
    ld c, (ix+DBS_CUR_SECTOR)
    ld b, 0
    add hl, bc              ; hl = zero-based sector number
    inc hl                  ; hl = one-based sector number
    ld b, h
    ld c, l                 ; bc = one-based sector number
    ld de, DBS_BUFFER
    add ix, de              ; ix = low bytes of physical address
    ld de, 1                ; de = sector count
    ld h, 0x06              ; high byte of physical address
    ret

; Switch from CP/M mapping to Brother OS mapping, with the BIOS at the top of
; memory.

sysin:
    exx
    pop hl                  ; return address
    ld (saved_stack), sp    ; save the CP/M stack pointer
    ld c, 0x88              ; expose the Brother ROM
    out0c CBAR
    ld sp, 0x31ad           ; switch to the Brother stack
    push hl
    exx
    ei
    ret                     ; exit

; Switch from the Brother OS mapping to the CP/M mapping.
; DO NOT TAIL CALL THESE.

sysout:
    di
    exx
    pop hl                  ; return address
    ld c, 0x00              ; map RAM in everywhere
    out0c CBAR
    ld sp, (saved_stack)
    push hl
    exx
    ret

drive_a_dbs:
    dw 12       ; number of sectors
    dw 78       ; number of tracks
    dw fd_r256  ; read callback
    dw fd_w256  ; write callback
    dw 0xffff   ; current sector
    dw 0        ; current track
    db 0        ; dirty flag
    ds 256      ; buffer

drive_a_dph:
    dw 0                    ; Sector translation vector
    dw 0, 0, 0              ; BDOS scratchpad
    dw dirbuf               ; Directory scratchpad
    dw drive_a_dpd          ; Drive parameter block
    dw drive_a_check_vector ; Disk change check vector
    dw drive_a_bitmap       ; Allocation bitmap

RESERVED_TRACKS = 4
DRIVE_A_BLOCKS = (78-RESERVED_TRACKS)*12*256 / 1024
drive_a_dpd:
    dw 12*2                 ; Number of CP/M sectors per track
    db 3, 7                 ; BSH/BLM for 1024-byte blocks
    db 0                    ; EXM for 1024-byte allocation units and <256 blocks
    dw DRIVE_A_BLOCKS-1     ; DSM
    dw 31                   ; DRM, one fewer than the number of directory entries
    db 0x80, 0x00           ; Initial allocation vector for one directory block
    dw 8                    ; Size of disk change vector: (DRM+1)/4
    dw RESERVED_TRACKS      ; Number of reserved tracks

drive_a_bitmap:
    ds (DRIVE_A_BLOCKS+7) / 8
drive_a_check_vector:
    ds 8
dirbuf:
    ds 128

saved_stack: dw 0            ; user stack pointer while in system calls
disk_off_count: db 0         ; cheap and nasty drive motor timer
current_sector: dw 0
current_track: dw 0
current_dma: dw 0

; vim: ts=4 sw=4 expandtab

